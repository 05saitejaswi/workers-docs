---
title: 'Debugging Tips'
weight: 20
---

## Error pages generated by Workers

When a Worker running in production has an error that prevents it from returning a response, the client will receive an error page with an error code, defined as follows:

| Error code | Meaning                                                                                                             |
| ---------- | ------------------------------------------------------------------------------------------------------------------- |
| 1101       | Worker threw a JavaScript exception.                                                                                |
| 1102       | Worker exceeded CPU time limit. See: [Resource Limits]({{< relref "archive/writing-workers/resource-limits.md" >}}) |
| 1015       | Your client IP is being rate limited.                                                                               |

<br>Other 11xx errors generally indicate a problem with the Workers runtime itself -- please [raise a support ticket](https://support.cloudflare.com/hc/en-us/requests/new) if you see one.

## Seeing errors in production / staging

Normally, you write and test your Worker in the playground. The playground includes a JavaScript console where you can see debugging info like `console.log()`s and uncaught exceptions. Hopefully, you can get your script working entirely in the playground before pushing.

However, due to technical limitations, the playground doesn't always exactly produce what will happen in production. We therefore recommend deploying your script to a test or "staging" site before making it live on your real site.

If you run into problems in staging or production, debugging is harder. `console.log()` does not work here, and uncaught exceptions produce a generic error page (error code 1101). We are working to make this experience better, but for now, here are some tips for debugging a live site:

### Return debug information in a header

A common quick hack to get some debug information out of your Worker is to return it as a header value in the response.

```javascript
addEventListener('fetch', event => {
  event.respondWith(handle(event.request))
})

async function handle(request) {
  let newUrl = myRewriteFunction(request.url)
  let response = await fetch(newUrl, request)

  // Copy the response so that we can modify headers.
  response = new Response(response.body, response)

  // Shove our rewritten URL into a header to find out what it was.
  response.headers.set('X-Debug', newUrl)

  return response
}

function myRewriteFunction(url) {
  return url + '?foo=bar'
}
```

### Make subrequests to your debug server

A Worker can make HTTP requests to any site on the public internet. Many projects already have a service like [Sentry](https://sentry.io/) set up to collect error logs from browser-side JavaScript. You can use the same service to collect errors from your Worker, by making an HTTP request to the service to report the error. Refer to your service's API documentation for details on what kind of request to make.

When logging using this strategy, you must account for a small but important detail: normally, any outstanding asynchronous tasks are canceled as soon as a Worker finishes sending its main response body back to the client. In order to ensure that a logging subrequest completes, you can pass its `fetch()` promise to [`event.waitUntil()`](https://developer.mozilla.org/en-US/docs/Web/API/ExtendableEvent/waitUntil). For example:

```javascript
addEventListener('fetch', event => {
  event.respondWith(handle(event))
})

async function handle(event) {
  let request = event.request
  let newUrl = myRewriteFunction(request.url)

  // Without event.waitUntil(), our fetch() to our logging service may
  // or may not complete.
  event.waitUntil(postLog(newUrl))

  return fetch(newUrl, request)
}

function postLog(data) {
  return fetch('https://log-service.example.com/', {
    method: 'POST',
    body: data,
  })
}

function myRewriteFunction(url) {
  return url + '?foo=bar'
}
```

### Wrap your whole event handler in a try/catch

If you're getting error code 1101 from your Worker, that means it is throwing an exception. You can catch the exception in your code using a regular old `try`/`catch` block. (Note that this works best if your code is factored into an `async` function, otherwise you also need to know how to catch exceptions from promises.)

```javascript
addEventListener('fetch', event => {
  event.respondWith(handle(event.request))
})

async function handle(request) {
  try {
    let newUrl = myRewriteFunction(request.url)
    return await fetch(newUrl, request)
  } catch (err) {
    // Display the error stack.
    return new Response(err.stack || err)
  }
}

function myRewriteFunction(url) {
  throw new Error('oops!')
}
```


